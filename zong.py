def 注释():
    # 单行注释:#
    # 多行注释:'''
    #         '''
    # Ctrl+/:选中的部分注释
    # Ctrl+z:撤销
    a=1
def 输出():
    def 直接输出():
        # print('文本1','文本2') #中间加逗号是用空格隔开，不加则会连到一起
        # print('文本1','文本2',sep='分割符')#加个sep，引号内的东西表示前面几句文本的分割符，\n是换行,不写则默认空格
        # print('文本1','文本2',sep='分隔符',end='结尾')#end引号内填以什么结尾，不写则默认是换行
        # print('文本')#输出：文本
        #print(数字/字符串)#纯数字则直接输出数字，含字母则为变量名，变量名未定义则报错
        a=1
    def 格式化输出():
        def 占位符():
            #占位符：%
            # %d整形，%s字符串
            # %md (m为整数)：m表示输出位数，比实际的多则前面补空格，少则参数无效
            # m换为<、>、^：左对齐，右对齐，^居中对齐
            # %0md（m为整数）：前面多出来的位数用0来补
            # %f ：浮点数
            # %n.mf（n，m为整数） n表示输出位数，m表示输出几位小数（四舍五入），m不写默认6位小数
            # %转义：%后的占位符原样输出不变，e.g.: %%d、%%f
            #print('文本1%d，文本2%d'%(变量1,变量2)）#变量1，变量2依次替换两个占位符
            a=1
        def 转义符():
            #e.g.：print('文本1\n文本2')
            # \t：制表符
            # \n：换行符
            # \转义：\后的转义符不变，e.g.：\\t、\\n
            # r:后面一个引号内的转义符都不变， e.g.：print(r'文本1\n文本2','文本3\t文本4') 第一个\n不变，第二个\t会变
            a=1
        def format():
            #print('文本1{}，文本2{}'.format(变量1,变量2)) #固定格式：变量1，变量2依次填到前面的{}中
            #格式化：:3d、:03d、:.2f，在{}内填占位符，把%换成:就好
            a=1
        def f_string():
            #print(f'文本1{变量1}，文本2{变量2}文本3')   #前面加上f，将{}内的当作变量名并替换为对应的值
            #格式化：在变量名后加上占位符，把%换成:
            a=1
def 变量():
    def 赋值():
        # =赋值
        # 直接写，会自动判断整形浮点型布尔型复数型
        # 加引号则表示是字符串
        a=1
    def 标识符():
        #由数字字母下划线组成
        #不以数字开头
        #不用关键字
        #严格区分大小写
        a=1
    def 数值类型():
        # 整形（int）、浮点型（float）
        #type(变量名)#返回变量的数值类型
        #布尔型（bool）：True、False（严格区分大小写）
        #布尔型通常用于判断
        #布尔型可以当作整形对待：True=1，False=0
        #复数型（complex）：a+bj，这里的j就相当于数学中的i
        a=1
def 输入():
    def input_1():
        #e.g.：变量=input('文本1') #运行时会输出文本1并等待输入，可以不写文本1，可以没有引号但必须有括号
        #默认输入并赋值给变量的是字符串，需要用时需要转换为其他类型
        a=1
def 运算符():
    def 基本运算符():
        # +、-、*、/  ：加减乘除
        #  //、%、** ：整除、整除取余、幂（小数有计算精度问题，要特殊处理）
        #  +=、-= ：自增，自减
        a=1
    def 关系运算符():
        # >、<、>=、<= ：比较
        # ==、!= ：等于，不等于
        a=1
    def 逻辑运算符():
        # and、not、or ：and 均符合，or 符合至少其中一个，not 不……
        a=1
    def 特殊运算符():
        #海象运算符：    := 作用和=相同 =只能单独使用，:=只能在语句中使用（一次计算多次使用，合并语句）（需要加括号：运算优先级低）
        a=1
def 分支结构():
    def if_1():
        # if 条件:
        #   语句
        # elif 条件:
        #   语句
        # else:
        #   语句
        #严格缩进，条件不需要加括号，一定要加:
        #只有几句if else的，化简为三元运算：  语句1 if 条件 else 语句2 #满足条件则执行语句1，不满足则执行语句2
        a=1
    def while循环():
        #while 条件:
        #   语句
        #严格缩进，条件不加括号，一定要加:
        #如果条件为True或任意不为0的常量则为死循环
        a=1
    def for循环():
        #for 临时变量 in 可迭代对象:
        #   语句
        #临时变量的生命周期只有这个循环
        #循环将可迭代对象依次赋给临时变量
        #可迭代对象：最常见：range（start,stop,step）#开始，结束，步长
        #range中只写一个数默认是stop，其他两个是1，
        #range中的start，stop，顾头不顾腚
        a=1
    def 循环控制():
        #break：结束这个循环，继续向下执行
        #continue：跳过当前循环周期继续下一个循环周期
        a=1
def 字符串():
    def 编码():
        # ASCII、GB2312、Unicode、GBK、UTF-8
        #encode()编码，decode()解码，（不写默认Unicode，加引号指定编码方式）字符串转换字节
        #函数：ord(单个字母)   #返回该字母的ASCII码
        a=1
    def 字符串运算符():
        #  +  ：字符串拼接，e.g.：print('文本1'+'文本2')  输出 文本1文本2 中间没有空格
        #  *  ：重复输出，  e.g.：print('文本1'*10)  将引号内的内容重复输出10遍
        a=1
    def 成员运算符():
        #  in  ：包含
        #  not in  ：不包含
        #检测字符串中是否包含了某个字符串，返回T和F
        a=1
    def 下标索引():
        #变量名[标号]
        #标号从0开始，从左到右，
        #负数：从右往左数
        a=1
        def 切片截取():
            #变量名[start:stop:step]
            #start ：不写默认0
            #stop ：不写默认最后一个
            #step ：不写默认1
            #start、stop ：索引表示位置编号
            #step ：大小表示步长，正负表示方向（正向右，负向左）
            #返回切后的字符串
            a=1
    def 字符串函数():
        def 查找():
            #find（从左向右）
            #变量名.find('字符串1',start,end)
            #变量：被查找的字符串
            #字符串1：要查找的字符串
            #start，end:查找开始，结束位置编号，不写默认0和最后
            #找到则返回找到的第一个要查在被查的开始位置的下标，找到一个就退出
            #未找到则返回-1
            #rfind：用法与find相同，是从右往左开始查找
            #index（从左向右）
            #用法与find相同，但未找到会报错
            #rindex：用法相同，从右往左
            #count
            #变量1.count('字符串1',start,end)
            #返回字符串1在变量1中的出现次数，无则返回0
            #start，end：开始结束位置，不写默认0和结尾
            a=1
        def 换():
            #replace
            #变量1.replace('字符串1','字符串2'，m)
            #替换变量1中的字符串1，为字符串2，m为替换次数
            def 大小写转换():
                #变量1.upper()：将变量1全换成大写
                #变量1.lower()：将变量1全换成小写
                #变量1.title()：将变量1中的每个单词首字母大写
                #变量1.swepcase()：将变量1中的大小写互换
                #变量1.capitalize()：将变量1的第一个字母大写
                a=1
        def 检查():
            #变量1.isalnum()：变量1全是字母或数字吗 返回T 或F
            #变量1.isalpha()：变量1全是字母吗
            #变量1.isdigit()：变量1全是数字吗
            #变量1.islower()：变量1全是小写字母或数字吗
            #变量1.isupper()：变量1全是大写字母或数字吗
            #变量1.isspace()：变量1全是空格吗
            #变量1.istitle()：变量1每个字母首字母都大写了吗
            #变量1.startswith('字符串1',start,stop)：start，stop开始结束位置编号，变量1从start到stop的字符串是以字符串1开始的吗
            #变量1.endswith('字符串1',start,stop)：start，stop开始结束位置编号，变量1从start到stop的字符串是以字符串1结束的吗
            a=1
        def 连与分():
            #分割：split()
            #变量1.split('分隔符')
            #去掉分隔符（不写默认空格），以列表形式返回
            #spiltline()：按行分
            #连接：join()
            #e.g.:a=['字符串1','字符串2','字符串3']
            #     b=('分隔符'.join(a))
            #用分割符连接a中的字符串并返回
            a=1
        def 去与填():
            #变量1.strip('字符串1')
            #移除变量1最左侧和最右侧的字符串1
            #不写默认移除空白字符（空格，换行，制表等）
            #当字符串1时多个字符时，会将其看作一个集合，去掉两侧所有包含在这个集合中的字符,直到遇到不是这个集合中的元素时停止
            #只去除两边，不影响中间
            #返回新字符串，不修改原来的字符串
            #lstrip：只去左边
            #rstrip：只去右边
            #变量1.center(m,'字符')
            #将变量1这个字符串填充到长度为m(整数)，若m小于原长度，则原样返回
            #'字符'可以不写，默认空格，只能写一个，写多个会报错
            #将原字符串居中，若填充长度不能均分则右侧多填充一个字符
            #ljust：左对齐，向右填充
            #rjust：右对齐，向左填充
            a=1
def 数据结构():
    def 列表_list():
        #一组有序的数据
        #用中括号表示 ： 列表名=[元素1,元素2,元素3,……]
        #元素类型任意，都可以写到一个列表中
        #类似字符串：有索引（从0开始），正负索引，切片
        def 列表操作():
            def 加():
                #列表名.append('元素x')  ：往列表里加一个‘元素x’（加到最后）
                #列表名.extend('可迭代对象1')  ：将可迭代对象1迭代后依次添加到列表中（依次往后加）
                #列表名.insert(m,'元素x')  ：将‘元素x’添加为索引为m的元素，原先的依次后移，（m大于原来所有索引则添加到最后）
                a=1
            def 改与查():
                #列表名[索引1]=元素x  ：修改列表中索引为‘索引1’的元素为‘元素1’
                #in   not in
                #'元素x' in 列表名    ：查找元素x是否在列表中，返回T或F
                #'元素x' not in 列表名    ：查找元素x是否不在列表中，返回T或F
                #列表名.index('元素x')   列表名.count('元素x')
                #用法与字符串的相同
                #列表的查找中没有find
                a=1
            def 删():
                #   e.g.    del 列表名[索引x]   #（独立语句）删除列表中索引为‘索引x’的元素 （改变了原列表）
                #           del 列表名         #（独立语句）删除整个列表，（如果未被赋值就再次使用就会报错）
                #           del 列表名[start:stop:step]    #用法与切片类似，删除指定元素
                #列表名.pop('索引x')  #(可作为独立语句，修改了原列表)删除列表中索引为‘索引x’的元素（括号内不写则默认删除第一个）
                #列表名.remove('元素x')    #(可作为独立语句，修改了原列表)删除列表中的第一个元素x，列表中若不存在元素x则报错
                a=1
            def 排序():
                #列表名.sort(key=函数名,reverse=正误)    #对原列表进行排序，(可作为独立语句，修改了原列表)
                #‘key=’和‘reverse=’：需要这个参数时需要写
                #key=  ：指定一个函数，用于提取每个元素用来比较的部分   e.g.： len（按长度排）；str.lower：（按小写字母排序（忽略大小写排序））；可直接写匿名函数（见后）
                #resever=  ：写True按降序排列（从大到小），写False则按升序排列（从小到大），不写默认升序
                #两个参数均非必要，都可以不写
                #sorted(列表名,key=函数,reverse=正误)    #用法与sort基本相同，但不修改原列表而是返回新列表
                #函数名.reverse()    #无参数，将列表中的元素倒序排列，可当作独立语句，会修改原列表
                #reverseed(列表名)   #无参数,将列表中的元素倒序排列，不修改原列表，返回新列表
                a=1
            def 列表推导式():
                #列表1=[表达式 for 变量 in 可迭代对象]
                #列表1=[表达式 for 变量 in 可迭代对象 if 条件]     相当于：   for 变量 in 可迭代对象:
                #                                                          if 条件:
                #                                                              表达式           #将表达式的结果当作列表的元素并进行下一个循环
                #表达式可以是列表.函数()，也可以是ifelse的一行版本
                #可用来修改或创建列表
                #可嵌套：列表1=[表达式 (for 变量1 in 可迭代对象1) (for 变量2 in 可迭代对象2) if 条件]  #括号只是示意，实际不用写，由左到右是从上到下
                #相当于：列表1=[]
                #      for 变量1 in 可迭代对象1:
                #          for 变量2 in 可迭代对象2:
                #              if 条件:
                #                  列表1.append(表达式)
                a=1
            def 列表嵌套():
                #列表中的元素可以是列表
                #直接加索引就可以正常用
                a=1
    def 元组_tuple():
        #元组名=(元素1,元素2,……)
        #只有一个元素也要加一个逗号
        #元组只能查，不能增不能删不能改
        #count，index，下标索引，切片等与列表用法相同
        #转换类型：元组1=tuple(列表1);列表1=list(元组1)
        a=1
    def 字典_dict():
        #字典名={键1:值1,键2:值2,……}
        #键值对用,隔开；键与值用:
        #键名不能重复（重复则按最后一个算），值可以重复
        def 字典操作():
            def 查():
                #字典名.get(键x,字符串1)   #字典中存在键x对应值则返回对应的值，否则返回字符串1，‘字符串1’可以不写，默认返回None
                #字典名[键x]        #返回键x对应的值，否则报错
                #字典1.setdefault(键x,字符串1)    #若字典1中有键x，则返回对应的值，若没有，则把键x添加到字典1（对应的值为字符串1）并返回字符串1
                a=1
            def 改():
                #字典1[键x]=字符串1   #若字典中有键x，则把键x对应的值改为字符串1，若字典中没有键x则把键x添加到字典1中（对应的值即为字符串1）
                #字典1.update(字典2)    #将字典2添加到字典1
                #字典1 |= 字典2      #将字典2添加到字典1
                a=1
            def 删():
                #  del 字典名     #（独立语句）删除整个字典
                #  del 字典名[键x]   #（独立语句）删除键x对应的键值对
                #  字典名.clear()      #（独立语句）清空整个字典，但保留这个字典
                #  字典名.pop(键x)    #删除字典中键名为‘键x’的键值对，并返回被删除的键x对应的值
                #  字典名。popitem()    #删除字典中最后一个键值对并返回该键值对的值
                a=1
            def 用():
                #len(字典名)  #返回该字典中键值对的数量
                #字典名.keys()  #返回包含该字典的所有键的视图对象（可通过函数强转成列表等）
                #字典名.values()   #返回包含该字典的所有值的视图对象（可通过函数强转成列表等）
                #字典名.items()   #返回包含该字典所有键值对的（以元组形式）视图对象（可通过函数强转成列表等）
                a=1
            def 字典推导式():
                #{(键语句:值语句) for 变量 in 可迭代对象}    #()不写，仅做示意
                #{(键语句:值语句) for 变量 in 可迭代对象 if 条件}     #()不写，仅做示意
                #与列表推导式类似
                a=1
    def 集合_set():
        #集合名={元素1,元素2,元素3,……}
        #a={} #a为空字典  =>  a=set() #a为空集合
        #无序性：集合元素为数字自动排序从小到大，元素为字符串时随机排序（与哈希值有关）
        #唯一性：自动去重
        def 集合操作():
            def 增删查():
                #集合1.add(元素x)  #将元素x添加到集合1中
                #集合1.update(可迭代对象)  #将可迭代对象迭代依次添加到集合1中
                #集合1.remove(元素x)   #将集合1中的元素x删去，不存在则报错
                #集合1.pop()    #删除集合1中的第一个元素，当元素全为字符串时表现为随机删除一个元素
                #集合1.discard(元素x)   #删除集合1中的元素x 无则不执行
                #  in 和 not in
                a=1
            def 交并差集():
                #交：&   集合1 & 集合2     #返回集合1和集合2的交集
                #并：|   集合1 | 集合2     #返回集合1和集合2的并集
                #差：-   集合1 - 集合2     #返回在集合1不在集合2的元素组成的集合
                #对称差：^   集合1 ^ 集合2   #返回由集合1和集合2的非公共元素组成的集合
                a=1
    def 冻结集合_frozenset():
        #集合名=frozenset([元素1,元素2,……])
        #元素不可重复，支持交并差运算
        #不同：创建后不可修改，可以作为字典的键，可以做为集合元素
        a=1
def 类型转换():
    #int()  #转换为整型，不四舍五入，有数字和正负号以外的字符会报错
    #float()  #转换为浮点数
    #str()  #转换为字符串类型
    #list()  #将可迭代对象转换为列表，字典转列表指挥取每一个键名，集合转列表前会去重并随机排
    #eval()   #执行一个字符串表达式，并返回结果，（可以把一个字符串当作一个表达式来运行）
    a=1
def 可迭代对象():
    #指可以被遍历（迭代）的对象(可通过for   in   等遍历读取的数据对象)
    #e.g.：列表，元组，集合，字典（取出每个键），range(),字符串（取出每个字符）
    a=1
def 深浅拷贝():
    def 可变与不可变对象():
        #不可变对象（Immutable）  =>  整型，浮点型，字符串，字节，元组，冻结集合等
        #可变对象（Mutable）   =>  列表，字典，集合，
        #不可变对象修改时相当于生成新的值，会改变内存地址
        #可变对象修改时不会改变内存地址
        #当把一个对象赋值给一个名称后，相当于这个名称指向了这个对象所在的内存地址，再次使用时即使用该内存地址中的内容，在使用=对待可变对象要格外注意
        #id(a)  #返回变量a指向的内存地址
        a=1
    def 浅():
        #只复制对象本身，不复制嵌套对象
        #变量1=copy.copy(对象1)  #复制对象1给变量1
        #   e.g.    a=[1,2,3,4,[5,6,7]]
        #           b=copy.copy(a)
        #           b.append(8)         #修改外层：在b中添加一个元素8，a不会变
        #           b[4].append(9)      #修改内层：在嵌套的列表中添加一个元素9，ab都会变
        #浅拷贝将对象本身复制了一份存在了一个新的内存地址中，嵌套对象依旧指向原地址
        a=1
    def 深():
        #递归复制对象及其嵌套对象（原样，全套复制）
        #变量1=copy.deepcopy(对象1)  #全套复制对象1给变量1
        #深拷贝是完全复制所有到一个新地址，完全不影响原来的
        a=1
    #深浅拷贝都是指可变对象，不可变对象不需要拷贝
def 函数():
    #定义：  def 函数名(参数):
    #           函数体
    #调用： 函数名(参数)
    #返回： 返回值并退出函数，  e.g.：  return 语句  #返回语句返回的结果，
    #无return则返回None
    def 函数参数():
        #e.g.：   def 函数名(形参1,形参2,……)   #定义
        #            函数体
        #         函数名(实参1,实参2,……)    #调用
        def 必备参数():
            #或叫位置参数
            #传递和定义参数的顺序，个数一致
            a=1
        def 默认参数():
            #放在必备参数后面，提前赋一个值
            #传参时传递了这个参数则按传递的来，没有传则按提前赋的来
            a=1
        def 可变参数():
            #一般写做： *args  #*必须写，args可以写成任意字符传，不过建议都写作args
            #传入的参数的数量可变，可以传多个，可以不传
            #e.g.：   def 函数名(*args)   #定义
            #            函数体
            #可变参数会接收并打包为一个元组，元组名即为args
            a=1
        def 关键字参数():
            #一般写做： **kargs  #**必须写，kargs可以写成任意字符传，不过建议都写作kargs
            #可传入任意数量的值，传入的值会被打包为一个字典，字典名即为kargs
            #以特殊格式传值：  键1=值1,键2=值2,……     #采用键等于值的格式
            a=1
        #四种参数顺序：  必备参数,可变参数,默认参数,关键字参数
    def 函数嵌套():
        #函数可以在定义的同时调用自己    #要保证范围逐渐减小，有明确退出条件，避免死循环
        #在函数内部定义函数：先定义再调用，定义与调用同级，注意缩进
        a=1
    def 作用域():
        #全局变量与局部变量（局部变量的名称可以相同，只要生命周期完全不同就行了）
        #global(变量x)    #独立语句，声明要在局部使用全局变量x，会修改全局变量的值
        #nonlocal(变量x)   #独立语句，声明要使用上一级嵌套中的变量，不影响上上级的变量和全局变量
        a=1
    def 匿名函数():
        #lambda 参数:表达式
        #用于简单函数，只有一个语句
        #可直接放在其他语句中使用
        #函数名=lambda 参数:表达式  #与普通函数相同
        a=1
    def 内置函数():
        #import builtins
        #查看都有哪些：  dir(builtins)  #返回所有内置函数 （大写开头为内置常量名，小写开头为内置函数名
        def 常见内置函数():
            def 绝对值():
                #abs(变量)  #返回变量的绝对值，若变量为复数则返回模长
                a=1
            def 求和():
                #sum(变量，默认参)  #求和（变量为可迭代对象），
                #默认参（非必须）：起始值
                #若可迭代对象为数，则在起始值上往上累加，
                #若可迭代对象为字符：直接用会抱错，可在默认参数位置写一对引号但不填任何内容，表示起始值为空字符串，即可正常将一个个字符合并为一个字符串
                a=1
            def 最大与最小():
                #min(参数1,参数2,……,key=函数1) #返回所有参数中的最小值
                #函数1用来定义比较方式
                #min(可迭代对象,key=函数,default=字符串)
                #可以只传一个参：可迭代对象：比较对象迭代后的内容（直接写字典的话是比较键），返回最小值
                #如果可迭代对象为空，则返回default对应的内容
                #key与default都可以不写
                #max用法类似，返回最大值
                a=1
            def 打包():
                #zip(可迭代对象1,可迭代对象2,……)
                #依次取每个可迭代对象中一个迭代元素，打包为一个元组
                #将每一个元组视为列表的一个元素，返回这个列表
                #当可迭代对象不一样长时，以最短的为准
                a=1
            def 依用():
                #map(函数1,可迭代对象)  #一般与list配合使用：list(map(函数1,可迭代对象)  ：将结果打包为一个列表
                #对可迭代对象的每一个迭代元素使用函数1并返回
                #可以用匿名函数
                a=1
            def 递进():
                #reduce(函数1,可迭代对象)  #需要先导包：from functools import reduce
                #函数1必须有且仅有两个必备参数，
                #取可迭代对象的前两个迭代对象做函数1的参，返回值再和可迭代对象的下一个迭代对象做函数1的参，直到最后一个，返回最终结果
                a=1
def 拆包():
    #变量名=可迭代对象
    #变量1,变量2,……=变量名
    #可迭代对象可以迭代多少次就需要多少变量
    #变量1,*变量2=变量名
    #取可迭代对象的迭代结果给变量等，多余的给可变参数2，变量2的类型为列表
    a=1
def 异常():
    def 返回异常():
        #raise Exception('内容')  #执行到此时程序报错并退出，返回“内容”
        a=1
    def 异常类型():
        def 所有异常_BaseException():
            #SystemExit：系统退出
            #KeyboardInterrupt：键盘输入中断
            #GeneratorExit：生成器退出
            def 内置非系统退出异常_Exception():
                # AssertionError:assert语句失败
                # AttributeError:访问对象不存在的属性
                # BufferError:缓冲区异常
                # EOFError:意外到达文件或输入流末尾（EOF = End Of File）
                # ImportError:导入模块错误
                # TypeError:类型错误，（例如不同类型数据相加）
                # MemoryError:内存溢出
                def 数值计算异常_ArithmeticError():
                    #ZeroDivisionError:除零错误
                    #OverflowError:数值运算超出最大限制
                    #FloatingPointError:浮点数运算异常（在纯Python中很少直接出现，通常在使用科学计算库时触发）
                    a=1
                def 查找异常_LookupError():
                    #IndexError:索引超出序列范围
                    #KeyError:字典中查找不存在的键
                    a=1
                def 访问未声明的变量_NameError():
                    #UnboundLocalError:访问的变量未被赋值
                    a=1
                def 输入输出错误_OSError_or_IOError():
                    #FileNotFoundError:文件未找到/路径不存在
                    #PermissionError:没有文件访问权限
                    #IsADirectoryError:尝试打开的是目录而非文件
                    #NotADirectoryError:尝试打开的是文件而非目录
                    #TimeoutError:操作超时
                    a=1
                def 运行异常_RuntimeError():
                    #NotImplementedError:方法未实现（抽象方法）
                    #RecursionError:递归深度超过限制
                    #StopIteration:迭代器耗尽
                    #StopAsyncIteration:异步迭代器耗尽
                    a=1
                def 语法错误_SyntaxError():
                    #IndentationError:缩进错误
                    a=1
                def 值异常_ValueError():
                    def Unicode字符串编码异常_UnicodeError():
                        #UnicodeEncodeError:将Unicode字符串编码为特定编码（如UTF-8、ASCII等）时异常
                        #UnicodeDecodeError:将字节序列解码为Unicode字符串时异常
                        a=1
    def 异常处理():
        #try,except,else,finally
        #try:   #单独一行，换行后缩进：可能发生异常的代码
        #except (异常类型1,异常类型2,……)     #独立一行，换行后缩进：处理特定异常
        #else:      #单独一行，换行后缩进：没有异常时执行
        #finally:    #单独一行，换行后缩进：不论有没有异常都执行
        a=1
def 模块():
    #一个py文件就可以看作一个模块
    def 模块分类():
        #内置模块
        #第三方模块（例如pygame）(在cmd中：pip install 模块名 #下载模块   pip list   #查看有哪些模块)
        #自定义模块：自己写的py文件，（与主文件在同一路径下）
        a=1
    def 导入模块():
        #import 模块名         #使用：模块名.函数名(参)
        #from 模块名 import 功能名（函数名）    #使用：函数名(参)  （即使用时不用再写模块名：不建议，不易读和维护）
        #from 模块名 import *    #导入这个模块中的所有函数，
        def as_():
            #起别名
            #import 模块名 as 别名  #使用时即可用别名取代模块名
            #from 模块名 import 功能名 as 别名   #使用该模块的这个功能时即可用别名代替
            a=1
def 内置全局变量():
    #  __name__
    #用来控制py文件在不同场景执行不同逻辑
    #直接执行时：__name__为__main__
    #当被作为模块导入时：__name__为模块名（即自己的文件名）
    a=1
def 包_python软件包_():
    #一个文件夹
    #作用：将有联系的模块放到同一个包下
    def 导包():
        #from 包名 import 包中的py文件名（模块名）       #使用：模块名.函数名(参)
        #from 包名 import import *          #导入整个包
        #在包中会自带一个文件 __init__.py  在导包时（不论导入所有或导入其中一个文件），都会先执行这个文件
        #在__init__.py中有一个变量__all__
        #__all__=['模块1','模块2',……]  #独立一行写在__init__.py中，在导入整个包时只导入__all__的几个模块
        a=1
    #包的本质也是模块，也可以导入其他包或模块
def 闭包():
    #函数嵌套
    #内层定义的函数使用外层函数变量
    #外层函数返回值为内层函数
    #e.g.:  def 函数1(参1):
    #           变量1=字符串
    #           def 函数2(参2):
    #               语句x（使用了变量1或参1）
    #           return 函数2
    #使用：  变量1=函数1(参1)        #创建了一个闭包（可以同时创建多个）
    #       变量1(参2)        #调用这个闭包（这个闭包记住了参1这个属性并执行语句x）
    def 装饰器():
        #在不改变原函数的情况下为其添加新功能
        #不改原函数，不改调用方法
        #e.g.:      def 装饰器名(fn):   #装饰器
        #               语句
        #               fn()
        #           def 函数名():     #原函数
        #               语句
        #           装饰器名(函数名)   #装饰原函数并调用函数
        #
        #e.g.:      def 装饰器名(fn):       #装饰器
        #               def 函数1():
        #                   语句
        #                   fn()
        #               reurn 函数1     #这里不要加括号
        #           def 函数名2():     #原函数
        #               语句
        #           函数名3=装饰器名(函数名2)   #装饰原函数作为一个新函数
        #           函数名3()         #调用装饰后的函数
        def 装饰器语法糖():
            #@装饰器名称
            #在原函数的上一行加上‘@装饰器名称’ 再次调用原函数时即为装饰过的函数
            #当一个函数添加了多个语法糖时（装饰器），从下往上执行，从最靠近原函数的开始执行
            a=1
        def 带参数的装饰器():
            #三层嵌套
            #即闭包加装饰器
            #e.g.:      def 装饰器名(参1):                      #带参装饰器
            #               def 函数1(fn):
            #                   def 函数2(*args,**kargs):
            #                       语句（使用参1）
            #                       result=fn(*args,**kargs)
            #                       return result
            #                   return 函数2
            #               return 函数1
            #           @装饰器名(参x)                         #装饰原函数并传入一个参数“参x”
            #           def 函数x(参a):
            #               语句（使用参a）
            #           函数x(参1)                            #调用装饰后的函数并将参1传递给参x
            a=1
#
#面向对象
#
def 面向对象():
    #面向过程与面向对象
    #面向过程：分析问题，注重过程，将其拆成一个个步骤，一个个方法，再依次调用一个个函数
    #面向对象：需要实现一个功能时，看重的是谁去帮我做这个事情
    def 类和对象():
        #类：对一系列具有相同属性和行为的事物的统称，（抽象概念，非真实存在）
        #格式：     class 类名:
        #              代码块
        #对象：类的具体表现，面向对象编程的核心，是类创建出来的真是存在的事物
        def 类的三要素():
            #类名
            #属性：对象的特征描述，用来说明是什么
            #方法：对象具有的功能，用来说明能做什么
            #e.g.:      类名：洗衣机类
            #           属性：长，宽，高，重量
            #           方法：洗衣服
            a=1
        def 类的基本格式():
            #   class 类名:       #类名必须符合标识符规定，大驼峰命名法
            #       代码块
            #洗衣机类e.g.:  class Washer:
            #                  height=800  #类属性
            #              Washer.height                   #返回类属性
            #              Washer.lengh=1                #属性存在类中则修改，不在则添加
            a=1
        def 创建对象():
            #也叫实例化对象
            #变量1=类名()           #创建一个名字为变量1的对象
            a=1
        def 实例方法():
            #由对象调用，至少有一个self参数，执行实例方法的时候，自动将调用该方法的对象赋值给self
            #方法即函数
            #e.g.:      class Washer():
            #               height=800
            #               def first(self):  #self参数是类中的实例方法必须具备的（必须写，不写会报错）,
            #                   print(123)
            #           aaa=Washer()
            #           aaa.first()            #调用方法
            #self参数即为对象本身，当对象调用实例方法时，python会自动将对象本身的引用作为参数，传递到实例方法的第一个参数self里
            a=1
        def 实例属性():
            #格式：self.属性名
            #e.g.:      class 类1():
            #               类属性1=值
            #               def 实例1(self):
            #                   print(f'{类名.类属性1}，{self.实例属性1}')    #self.实例属性1就是实例属性
            #           对象1=类1()            #创建对象
            #           对象1.实例属性1=值       # 为实例属性赋值
            #           对象1.实例1()           #调用实例
            #类属性与实例属性区别：类是公共的，大家都能访问到，实例属性是对象的只有这个对象可以访问
            a=1
        def 构造函数():
            #__init__()
            #作用：通常用来做属性初始化或者赋值操作
            #注意：在类实例化对象时会被自动调用
            #   def __init__():
            #       语句1
            #在创建对象时就会自动调用__init__,（即自动执行语句1）
            #在这里放：  self.实例属性1=值
            #e.g.:      class 类1:
            #               def __init__(self,变量1):
            #                   self.实例属性1=变量1
            #               def 实例1(self):
            #                   print(f'这是{self.实例属性1}')
            #           对象1.类1(值1)            #创建了一个对象，并把值1赋给对象1的实例属性1，
            #           对象1.实例1()             #调用实例
            a=1
        def 析构函数():
            #__del__()
            #删除对象
            #e.g.:      class 类1:
            #               def __init__():
            #                   print(1)
            #               def __del__():
            #                   print(2)
            #           对象1.类1()
            #           语句x
            #正常运行不会调用__del__()，结束时会自动调用__del__()
            #           del 对象1         #删除对象1（即调用类1中的__del__）内存立即被回收
            a=1
def 面向对象的三大特性_封装_继承_多态():
    def 封装():
        #隐藏对象中一些不希望被外部访问到的属性或方法
        #e.g.:      class 类1:
        #               类属性1=值
        #           对象1=类1()
        #           对象1.类属性1;类1.类属性1        #类属性均可访问，可修改
        #隐藏属性（私有权限）：双下划线开头，只允许在类的内部使用，无法在外部直接访问，子类不会继承，在另一个py文件中使用‘from xxx iomport *’无法导入
        #e.g.:      class 类2:
        #               类属性1=值1
        #               __类属性2=值2
        #           对象1=类2
        #           对象1.类属性1；类2.类属性1        #公开属性可以直接访问：对象与类都可以
        #           对象1.类属性2；类2.类属性2        #隐藏属性不可访问：两种均会报错
        #隐藏属性实际上是python自动改名：将'__类属性2'自动改为了'_类2__类属性2' => 将名字改成这个即可在外部访问，可在外部修改（在类的内部访问是原名，在外部访问是改后的名）
        #
        #私有属性：单下划线开头，声明私有属性或方法，如果定义在类中，外部可以使用，子类也可以继承，但在另一个py文件中使用‘from xxx iomport *’无法导入
        #这种命名一般是python中的魔术方法或属性，都是具有特殊含义或者功能的，自己不要轻易定义
        #e.g.:      class 类1:
        #               类属性1=值1
        #               _类属性2=值2
        #               __类属性3=值3
        #           对象1=类1()
        #           对象1._类属性2           #报错：不可访问
        #           类1._类属性2            #不报错，可以访问
        #
        #e.g.:      class 类2:
        #               def __实例1():
        #                   语句1
        #               def _实例2():
        #                   语句2
        #               def 实例3(self):
        #                   语句3
        #                   self.__实例1()
        #           对象1=类2()
        #           类2._实例2()           #可通过类名在类外调用
        #           对象1.实例3()
        a=1
    def 继承():
        #让类与类之间转变为父子关系，子类默认继承父类的属性和方法（子类可以用自己的也可以用父类的）
        #e.g.:      class 类1:
        #               def 实例1(self):
        #                   print(1)
        #               def 实例2(self):
        #                   print(2)
        #           class 类2(类1):
        #               pass                        #占位符，自动跳过，不执行不报错
        #           class 类3(类2):
        #               pass
        #           对象1=类3()
        #           对象1.实例1()           #可以调用
        #继承：可以一传多
        #继承的传递：多重继承=>A继承B，B继承C，C继承D，A可以使用ABCD中所有的
        #重写:方法覆盖：在子类中定义与父类相同名称的实例方法
        #e.g.:      class 类1:
        #               def 实例方法1(self):
        #                   语句1
        #           class 类2(类1):
        #               def 实例方法1(self):
        #                   语句2
        #           对象1=类2()
        #           对象1.实例方法1         #子类中有先用子类中的
        #扩展:方法扩展：在子类中扩展父类实例方法
        #e.g.:      class 类1:
        #               def 方法1(self):
        #                   语句1
        #           class 类2(类1):
        #               def 方法1(self):
        #                   类1.方法1(self)            #父类名.方法名(self)
        #                   语句2
        #           对象1=类2()
        #           对象1.方法1()               #不覆盖父类中的方法1，在执行完‘语句1’后执行‘语句2’
        #super().方法名()     #super在python是一个特殊的类，
        #super(子类名,self)
        #super()是使用super类创建出来的对象，可以调用父类中的方法
        # e.g.:      class 类1:
        #               def 方法1(self):
        #                   语句1
        #            class 类2(类1):
        #                def 方法1(self):
        #                    super().方法1()          #也可以调用继承父类中的其他方法
        #                    语句2
        #            对象1=类2()
        #            对象1.方法1()
        a=1
        def 新式类写法():
            #class A   #经典类：不由任意内置类型派生出的类
            #派生类：子类继承父类，子类有不同于父类的属性，方法，子类即为派生类
            #class A()   #经典类
            #class A(object)    #新式类：继承了object类或者该类子类的都是新式类
            #object ——对象，python为所有对象提供的基类，提供了一些内置的属性和方法，（可以使用dir()查看）
            #python3中如果一个类没有继承任何类，则默认继承object类 => python3都是新式类
            a=1
        def 多继承():
            #子类可以有多个父类，并同时具有所有父类的属性和方法
            #e.g.:      class 类1:
            #               def 方法1(self):
            #                   pass
            #           class 类2:
            #               def 方法2(self):
            #                   pass
            #           class 类3(类1,类2):
            #               pass
            #           对象1=类3
            #           对象1.方法1;对象1.方法2         #子类可同时使用两个父类的属性和方法
            #如果有同名的方法，优先使用自己的方法，自己没有则会使用排在前面那个父类的方法
            #python中的内置属性__mro__可以查看当前类的方法调用顺序：类3.__mro__  #返回方法查找顺序
            #多继承更容易引发冲突，让代码复杂度增加
            a=1
    def 多态():
        #指同一种行为具有不同的表现形式
        #多态的前提：继承，重写
        #特点：不关注对象类型，关注对象具有的行为，也就是对象的方法是否同名
        #好处：增加了代码的灵活度，让代码更通用，
        #不同的子类对象，调用相同的父类方法，会产生不同的执行结果
        #多态性：一种调用方法，不同的执行结果
        #e.g.:  class 类1:
        #           def 方法1(self):
        #               print(1)
        #       class 类2(类1):
        #           def 方法1(self):
        #               print(2)
        #       class 类3(类1):
        #           def 方法1(self):
        #               print(3)
        #       def 接口1(形参):
        #           形参.方法1()
        #       aaa=类1()
        #       bbb=类2()
        #       ccc=类3()
        #       接口1(aaa)        #1
        #       接口1(bbb)        #2
        #       接口1(ccc)        #3
        #接口函数传入不同的对象，执行不同不同对象的方法1
        a=1
def 在类中定义():
    def 静态方法():
        #使用@staticmethed来进行装饰，静态方法没有self，cls的限制
        #静态方法既可以使用对象访问，也可以使用类访问
        #可以理解为与类无关，只是写在类中，直接采用类访问在任何地方使用
        #e.g.:      class 类1:
        #               @staticmethod
        #               def 方法1(name):          #不用写self了
        #                   print(f'{name}1')
        #           类1.方法1('zzz')        #类访问
        #           aaa=类1()
        #           aaa.方法1('zzz')       #对象访问
        a=1
    def 类方法():
        #使用装饰器@classmethed来标识为类方法，对于类方法，第一个参数必须是类对象，一般是以cls作为第一个参数
        #e.g.:      class 类1:
        #               @classmethod
        #               def 方法1(cls,形参)     #cls代表类本身，类 本质上就是一个对象
        #                   语句
        #类方法内部可以访问类属性，或者调用其他类方法
        a=1
    #实例方法：内部访问实例属性，也可以通过类名.属性名来访问类属性
    #静态方法：不需要访问类属性和实例属性，可以访问类属性，不能访问实例属性
    #类方法：方法内部只需要访问类属性可以通过cls，不能访问实例属性
    #e.g.:      class 类1:
    #               属性1=值1      #类属性
    #               def __init__(self,形参1):
    #                   self.属性2=形参1     #实例属性
    #               def 方法1(self):          #实例方法
    #                   print(f'{类1.属性1}')  #访问类属性
    #                   print(f'{self.属性2}')    #访问实例属性
    #               @staticmethed
    #               def 方法2():          #静态方法
    #                   print(f'{类1.属性1}')      #访问类属性
    #                   print(f'self.属性2')      #会报错，不可访问
    #               @classmethed
    #               def 方法3(cls):           #cls代表类本身
    #                   print(f'{cls.属性1}')     #通过cls访问类属性
    #                   print(f'{self.属性2}')    #会报错，不可访问
    #类属性是公共的，所有方法内部都能访问到，静态方法不需要访问类属性
def 单例模式():
    #__init__()     #在创建对象时会自动执行的函数
    #__new__()      #object类提供的内置的静态方法
    #作用：在内存中为对象分配空间，返回对象的引用
    #需要参数：cls,*args,**args
    #实际上是先执行__new__，在__new__中会执行__init__
    #扩展重写：      class 类1:
    #                  def __new__():
    #                      语句1
    #                      参1=super().__new__(cls)
    #                      return 参1
    #重写一定要return super().__new__(cls),
    #在__init__之前写
    #实例化过程：
    #先执行__new__，没有写则默认调用object里面的，返回一个实例对象=>创建
    #再去调用__init__，对对象进行初始化
    #单例模式：一种常用的软件设计模式，
    #目的：确保某一个类只有一个实例存在
    #可以理解为一个特殊的类，这个类只存在一个对象
    #节省空间，但多线程时容易引发线程安全问题
    #可以通过@classmethed、装饰器、导入模块实现
    #通过重写__new__()实现：重点
    #让实例化多个对象时指向同一个对象(相同的内存地址)
    #定义一个类属性，初始为none,用来记录单例对象的引用
    #重写__new__():是初始值则赋值，不是则直接使用
    #e.g.:  class 类1:
    #           obj=None
    #           def __new__(cls,*args,**kargs):
    #               if cls.obj==None
    #                   cls.obj=super().__new__(cls)
    #               return cls.obj
    #让每一次都是同一个实例
    #在另一个py文件中写一个类并实例化一个对象，然后当作一个模块导入（from 文件名 import 实例对象 as 名1）：可以导入多次，写不同的名，都是同一个实例对象
    #模块就是天然的单例模式
    a=1
def 魔法方法_属性():
    #指python中具有特殊功能的函数：__xx__
    #__new__和__init__和__del__也是
    def __doc__属性():
        #魔法属性
        #函数or类的描述信息
        #e.g.:   class 类1:
        #           '''zzz
        #              yyy
        #              xxx'''
        #           pass
        #        print(类1.__doc__)
        #类名.__doc__  返回定义中的第一个多行注释的内容
        #无法返回第二个多行注释内容，也无法返回单行注释的内容
        a=1
    def __module__and__class__属性():
        #__module__  表示当前操作对象所在的模块
        #__class__   表示当前操作对象所在的类
        #e.g.:  在‘文件1.py’中写一个‘类1’（类1中有方法1）
        #       import 文件1
        #       参1=文件1.类1       #创建
        #       参1.方法1           #调用
        #       print(参1.__module__)     #返回模块名‘文件1’并打印出来
        #       print(参1.__class__)      #返回类名并打印出来
        a=1
    def __str__方法():
        #返回对象的描述信息
        #在类中定义此方法了，在直接打印对象时，会输出该对象的返回值（return的内容）
        #__str__()必须返回一个字符串
        #e.g.:  class 类1:
        #           def __str__(self):
        #               return '字符串'
        #        对象1=类1()
        #        参1=对象1
        #        print(参1)           #会输出‘字符串’
        a=1
    def __call__方法():
        #使一个实例对象成为一个可调用对象，像函数那样可以调用
        #可调用对象：函数、内置函数和类都是可调用对象。（即看可不可以把()应用到某个对象身上，可以就是可调用对象）
        #callable()  判断一个对象是不是可调用对象：是则返回True不是则返回False
        #e.g.:  def aaa():
        #           print(1)
        #       bbb='abc'
        #       print(callable(aaa))        #True
        #       print(callable(bbb))        #False
        #       class 类1:
        #           def __call__(self,*args,**kargs)
        #               pass
        #       aaa=类1()
        #       aaa()       #此时即执行__call__方法
        #       print(callable(aaa))        #此时即为True
        a=1
def 文件操作():
    #打开文件=>读写=>关闭
    #open('打开文件的路径'，encoding='编码方式')  创建一个file对象，默认以只读方式打开，移动文档指针到最后（gbk或utf-8）(不写路径只写名默认跟当前文件同一路径下的文件)
    #read(n) n表示从文件中读取的数据长度，没有传n或n为负值默认一次性读取所有,
    #write() 将指定内容写入文件
    #close() 关闭文件
    def 属性():
        #文件名.name  放回要打开的文件的文件名，可以包含文件的具体路径
        #文件名.mode  返回文件的访问方式
        #文件名.closed  检测文件是否关闭，关闭就返回True
        a=1
    #open和close一定要配合使用
    #=>  参1=open('文件名.txt')  #开
    #    参1.close()            #关
    def 文件读():
        #read(n)   读取文件
        #e.g.:  参1=open('文件名.txt',encoding='utf-8')
        #       print(参1.read())        #打印文档内容
        #       参1.close()
        #readline()     一次读取一行内容，并把文档指针移动到下一行
        #readlines()        按行读取整个文件，返回一个列表，每一行的数据就是列表中的一个元素
        a=1
    def 访问模式():
        #在read中：read('文件','权限',encoding='编码')
        #r:只读，文件必须存在，不存在则报错，文件指针在开头
        #w:只写，文件存在则清空并写入内容，不存在则创建并写入内容
        #a:追加模式，文件存在则在原来文件中继续往后写，不存在则创建（不可读）
        #x:独占创造，创建新文件并写，若文件存在则报错
        #+: 表示可以同时读写
        #r+:可读写，存在则编辑，不存在则报错，文件指针在开头，打开时不清空文件，写时从当前文档指针所在位置开始写，覆盖后边的内容
        #w+:可读写，存在则编辑，不存在则创建，文件指针在开头，打开时会清空文件，写时从当前文档指针所在位置开始写，覆盖后边的内容
        #a+:可读写，存在则编辑，不存在则创建，文件指针在结尾，打开时不清空文件，写时不论文档指针在哪固定往末尾后追加
        #x+:可读写，存在则报错，不存在则创建，文件指针在开头，打开时会清空文件，写时从当前文档指针所在位置开始写，覆盖后边的内容

        #模式修饰符
        #t:文本模式，未指定则默认为此，处理文本文件，自动进行编解码，编解码方式错误则报错或，呈现乱码，读取时返回字符串
        #b:二进制模式，处理图片，视频，音频时使用，读取时返回字节,
        a=1
    def 文件定位():
        #文件指针：标记文件操作的位置（读、写）
        #seek(offset,whence) 移动文件指针到指定位置：offset：要移动的字节数;whence：文件指针的参考位置，默认0，表示文件开头，1表示当前位置，2表示文章结尾
        #参1.seek(0,0)   移动指针到文件开头
        #tell()   显示文件指针当前位置（从文件开头到文档指针位置的字符数）
        a=1
    def with语句():
        #with open  代码执行完，系统会自动调用close()，可以省略文件关闭步骤
        #e.g.:      with open('文件1.txt','权限') as 参1:
        #               参1.write('文本')
        a=1
    def 编码格式():
        #常见：gbk和utf-8  utf-8可以写中文，gbk不行（Windows默认gbk）
        #read('文件名.txt',encoding='编码格式')
        #图片视频音频：b
        #e.g.:  with open(r'路径/文件名','rb') as 参1:
        #            参2=参1.open()
        #       with open(r'新路径/新文件名','wb') as 参3:
        #            参3.write(参2)                           将原路径下的文件复制到新路径下
        a=1
def 目录操作():
    #导入所需模块：   import os
    #重命名：   os.rename('旧名字'，'新名字')   #独立语句，新旧名字中都要写后缀
    #删除：     os.remove('文件名')           #独立语句，名字中需要写后缀
    #创建文件夹：os.mkdir('文件夹名')           #独立语句，名字中没有后缀
    #删除文件夹：os.rmdir('文件名')             #独立语句，名字中没有后缀
    #获取当前目录：os.getcwd()                 #返回当前文件所在目录
    def 获取目录列表():
        #os.listdir()     #返回当前文件所在目录下的文件名，文件夹名
        #os.listdir('路径')#返回指定路径下的文件列表（最后不要多加了/）
        #os.listdir('../')#返回当前文件所在的上一级目录下的文件名，文件夹名
        a=1
def 迭与生():
    def 迭代器_iterator():
        #可迭代对象（iterable），可遍历的
        #遍历：依次从对象中把一个个元素取出来的过程
        #条件：对象实现了__iter__()方法，__iter__()方法返回了迭代器对象
        def for循环的原理():
            #先通过__iter__()获取了可迭代对象的迭代器
            #对获取到的迭代器不断调用__next__()方法来获取下一个值并将其赋值给临时变量
            a=1
        #判断一个对象是不是可迭代对象或已知的数据类型： isinstance()
        #需要导入：from collections import Iterable,Iterater（3.3以前） 现：from collections.abc import Iterable,Iterator
        #isstance(对象,类型)  判断对象是不是该类型，是则返回True不是则返回False
        #类型：可以用括号写多个：  (类型1,类型2)  即一个元组，有一个符合即返回True
        #
        #迭代器：一个可以记住遍历位置的对象，从第一个到最后一个，不会后退
        #e.g.:  可迭代对象1=[1,2,3,4,5]
        #       参1=iter(可迭代对象1)     #创建迭代器，可以写成： 参1=可迭代对象1.__iter__()
        #       参2=next(参1)            #next()每运行一次获取当前一个元素并移动到下一个数据，可以写成：参2=参1.__next__()
        #iter()调用对象的__iter__()，并把__iter__()方法的返回结果作为自己的返回值
        #next()调用对象的__next__(),即一个个取元素
        #当取完最后一个元素后再次运行next()将触发StopIteration异常
        #可用for的都是可迭代对象
        #可用next的都是迭代器对象
        #可迭代对象不一定是迭代器对象，迭代器对象一定是可迭代对象
        #可迭代对象可通过iter转换成迭代器对象
        #（dir(对象)）有__iter__但没有__next__为可迭代对象，两个都有则为迭代器对象
        #迭代器协议：对象必须提供一个next方法，执行该方法要么返回迭代中的下一项，要么就引发StopIteration异常来终止迭代
        def 自定义迭代器类():
            #要有两个特性：__iter__()和__next__()
            #e.g.:  class 类1:
            #           def __init__(self):
            #               self.参1=1
            #           def 方法1(self):
            #               print(self.参1)
            #               self.参1 += 1
            #           参2=类1()
            #           for i in range(5)
            #               参2.方法1()                #输出1 2 3 4 5
            #           for i in 参2                 #报错：类型不匹配
            #       class 类2:
            #           def __init__(self):
            #               self.参3=0
            #           def __iter__(self):
            #               return self
            #           def __next__(self):
            #               if self.参3 == 10
            #                   raise StopIteration('终止')
            #               self.参3+=1
            #               return self.参3
            #           参4=类2()
            #           for i in 参3
            #               print(i)
            a=1
    def 生成器_generator():
        #python中一边循环一边计算的机制
        def 生成器表达式():
            #e.g.:      参1=[i*5 for i in range(5)]      #列表推导式
            #           参1=(i*5 for i in range(5))      #生成器表达式，此时参1为迭代器对象，
            #           for i in 参1                     #用next遍历取值
            #               print(i)
            a=1
        def 生成器函数():
            #使用了yield关键字的函数
            #yield作用：类似return，将指定值或多个值返回给调用者
            #yield语句一次返回一个结果，在每个结果中间挂起函数，执行next()，再重新从挂起点继续往下执行
            #e.g.:  def 函数1():          #普通函数
            #           print(1)
            #       函数1()               #输出1
            #       def 函数2():
            #           yield 'a'
            #           yield 'b'
            #           yield 'c'
            #        参1=函数2()
            #       print(next(参1))        #这一句重复执行3次，依次输出a b c
            #       def 函数3(n):
            #           参2=[]
            #           a=0
            #           while a<n:
            #               参2.append(a)
            #               yield a
            #               a+=1
            #           print(参2)
            #       for i in 函数3(值1)
            #           print(i)            #依次输出0到值1，最后一个输出整个列表
            a=1
    #可迭代对象包含迭代器对象，迭代器对象包含生成器对象
def 线程():
    def 多任务():
        #声明函数，再调用函数，一个一个执行，=>单线程
        #线程：cpu调度的基本单位，每个进程至少都会有一个线程，这个线程通常就是我们所说的主线程
        #进程：操作系统进行资源分配的基本单位，打开一个程序至少有一个进程
        #一个进程默认有一个线程，一个进程里面可以创建多个线程
        #导入线程模块：  import threading
        #e.g.:      def 函1():           要用的函数（多任务）
        #               print(1)
        #               time.sleep(3)
        #               print(2)
        #           def 函2():
        #               print(3)
        #               time.sleep(3)
        #               print(4)
        #           aaa=threading.Thread(target=函1)    写函数名不用加括号
        #           bbb=threading.Thread(target=函2)    创建子线程
        #           aaa.start()      开启子线程
        #           bbb.start()
        #           #同时输出1 2，三秒后同时输出3 4
        #设置为守护线程：在创建线程后，开启线程前： aaa.deamon = True;bbb.deamon = True
        #当被设置为守护线程后，当所有非守护线程（包括主线程）结束时，守护线程会自动终止，无论是否执行完成
        #阻塞主线程：在开启子线程后：  aaa.join();bbb.join()   暂停，等子线程执行结束后，主线程才会继续执行，
        #获取线程名：   aaa.getName()  返回线程名字：默认Thread-1 Thread-2
        #改线程名：aaa.setName('新名字1')  设置线程aaa的名字为  新名字1
        #传参：args:元组格式传参，kargs:字典格式传参
        #      e.g.   aaa.threading.Thread(target=函数名,args=('参数1',))  #元组中只有一个参数时要加一个逗号
        a=1
        def 多线程特点():
            #无序、共享资源、资源竞争
            #无序：cpu调度决定
            #在合理的地方阻塞
            a=1
    def 线程同步():
        #在合理位置阻塞：在一个线程完成后再进行下一个进程
        def 互斥锁():
            #互斥锁：对共享数据进行锁定，保证多个线程访问数据不会出现数据错误问题
            #导入模块：  from threading import Lock
            #在函数中写：   lock.acquire()    上锁：在调用共享资源之前
            #             lock.release()    解锁：在使用完共享资源后
            #保证同一时刻只有一个变量在操作共享数据
            #一定要成对出现，否则容易造成死锁
            #互斥锁是多个线程一起去抢，先抢到的先执行
            #缺点：会降低代码的执行效率
            a=1
def 进程():
    def 进程状态():
        #就绪状态：所有条件都满足，等待cpu执行
        #执行状态：cpu正在执行其功能
        #等待（阻塞）状态：等待某些条件满足后再执行
        a=1
    def 进程语法结构():
        #multiprocessing模块：提供Process类，代表进程对象=>import multiprocessing import Process
        #大概率会用的   import os
        #Process类参数
        #targer:执行的目标任务名，即子进程要执行的任务
        #args，kargs传参
        #方法
        #进程名.方法()
        #start()  开启子进程
        #is_alive()  判断子进程是否还活着，存活则返回True,死亡则返回False
        #join()   阻塞子进程，等待子进程执行结束
        #常用属性
        #进程名.属性
        #name   当前线程名
        #pid   当前线程编号
        # e.g.:      def 函1():           要用的函数（多任务）
        #               print(1)
        #               time.sleep(3)
        #               print(2)
        #           def 函2():
        #               print(3)
        #               time.sleep(3)
        #               print(4)
        #           aaa=multiprocessing.Process(target=函1)    写函数名不用加括号
        #           bbb=multiprocessing.Process(target=函2)    创建子进程
        #           aaa.start()      开启子进程
        #           bbb.start()
        #           print(aaa.name)    输出进程名
        #可以在创建进程时改名：aaa=multiprocessing.Process(target=函1,name='进程1')
        #           print(aaa.pid)    输出进程编号
        #os.getpid()    返回当前进程编号
        #os.getppid()    返回父进程的id
        #进程间不共享全局变量
        #创建子进程一定要写if __name__=="__main__":
        #在创建子进程时：会创建全新的python解释器进程，子进程会重新导入这个模块，重新执行模块级代码
        #如果没有判断：子进程又执行了创建子进程的代码，无限递归的创建进程，最终程序崩溃
        a=1
    def 进程间的通信():
        #queue  队列
        #q.put()   放入数据
        #q.get()   取出数据
        #q.empty() 判断队列是否为空
        #q.qsize() 返回当前队列包含的信息数量
        #q.full()  判断队列是否满了
        #导入模块     from queue import Queue：单进程的多线程之间
        #           from multiprocessing import Queue ：多进程之间
        #初始化一个队列对象      变量1=Queue(n)  表示最大可以接受n个数据，如果n为负数，则队列没有上限
        #把值1放入队列‘变量1’中  变量1.put('值1')
        #获取队列的一条消息      变量2=变量1.get()  存入变量2，然后将其从队列中移除
        #从上往下放，也按同样的顺序从上上往下取
        a=1
def 进程池线程池():
    def 线程池():
        #1234567
        a=1
    def 线程池():
        #2234567
        a=1
